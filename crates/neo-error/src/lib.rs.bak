//! # Neo Error
//!
//! Error types and handling for the NeoRust SDK.
//!
//! This crate provides error types and handling utilities for the Neo N3 blockchain SDK, including:
//!
//! - Common error types used across the SDK
//! - Error conversion traits
//! - Error handling utilities
//! - Integration with standard Rust error handling

#![warn(missing_debug_implementations, missing_docs, rust_2018_idioms, unreachable_pub)]
#![deny(rustdoc::broken_intra_doc_links)]

use std::error::Error as StdError;
use std::fmt;
use thiserror::Error;

/// Errors that can occur when working with providers.
#[derive(Error, Debug)]
pub enum ProviderError {
    /// An error occurred with a JSON-RPC request.
    #[error("JSON-RPC error: {0}")]
    JsonRpcError(String),
    
    /// An error occurred with a WebSocket connection.
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    
    /// An error occurred with an HTTP request.
    #[error("HTTP error: {0}")]
    HttpError(String),
    
    /// An error occurred during serialization or deserialization.
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    /// An error occurred with a contract.
    #[error("Contract error: {0}")]
    ContractError(String),
    
    /// An error occurred with a transaction.
    #[error("Transaction error: {0}")]
    TransactionError(String),
    
    /// An error occurred with a network connection.
    #[error("Network error: {0}")]
    NetworkError(String),
    
    /// An error occurred with authentication.
    #[error("Authentication error: {0}")]
    AuthenticationError(String),
    
    /// An error occurred with a rate limit.
    #[error("Rate limit error: {0}")]
    RateLimitError(String),
    
    /// An error occurred with a subscription.
    #[error("Subscription error: {0}")]
    SubscriptionError(String),
    
    /// An error occurred with a timeout.
    #[error("Timeout error: {0}")]
    TimeoutError(String),
    
    /// An error occurred with a middleware.
    #[error("Middleware error: {0}")]
    MiddlewareError(String),
    
    /// An unknown error occurred.
    #[error("Unknown error: {0}")]
    UnknownError(String),
}

/// Errors that can occur during encoding and decoding operations.
#[derive(Error, Debug, PartialEq, Eq, Clone)]
pub enum CodecError {
    /// Invalid passphrase provided
    #[error("Invalid passphrase: {0}")]
    InvalidPassphrase(String),
    
    /// Invalid format encountered
    #[error("Invalid format")]
    InvalidFormat,
    
    /// Index out of bounds
    #[error("Index out of bounds: {0}")]
    IndexOutOfBounds(String),
    
    /// Invalid encoding
    #[error("Invalid encoding: {0}")]
    InvalidEncoding(String),
    
    /// Invalid operation code
    #[error("Invalid op code")]
    InvalidOpCode,
    
    /// Error converting from primitive
    #[error("Error converting from primitive: {0}")]
    TryFromPrimitiveError(String),
}

/// Custom error type for contract-related errors
#[derive(Error, Debug)]
pub enum ContractError {
    /// Error indicating an invalid Neo name
    #[error("Invalid NNS name {0}")]
    InvalidNeoName(String),
    
    /// Error indicating an invalid Neo Name Service root
    #[error("Invalid NNS root {0}")]
    InvalidNeoNameServiceRoot(String),
    
    /// Error indicating an unexpected return type
    #[error("Unexpected return type {0}")]
    UnexpectedReturnType(String),
    
    /// Error indicating an unresolvable domain name
    #[error("Unresolvable domain name {0}")]
    UnresolvableDomainName(String),
    
    /// Error indicating that a domain name is not available
    #[error("Domain name {0} is not available")]
    DomainNameNotAvailable(String),
    
    /// Error indicating that a domain name is not registered
    #[error("Domain name {0} is not registered")]
    DomainNameNotRegistered(String),
    
    /// Error indicating a runtime error
    #[error("Runtime error: {0}")]
    RuntimeError(String),
    
    /// Error indicating an invalid state error
    #[error("Invalid state error: {0}")]
    InvalidStateError(String),
    
    /// Error indicating an invalid argument error
    #[error("Invalid argument error: {0}")]
    InvalidArgError(String),
    
    /// Error indicating a provider error, transparently wrapped
    #[error(transparent)]
    ProviderError(#[from] ProviderError),
    
    /// Error indicating that a provider is not set
    #[error("Provider not set: {0}")]
    ProviderNotSet(String),
    
    /// Error indicating that an invocation failed
    #[error("Invocation failed: {0}")]
    InvocationFailed(String),
    
    /// Error indicating an invalid response
    #[error("Invalid response: {0}")]
    InvalidResponse(String),
    
    /// Error indicating an invalid account
    #[error("Invalid account: {0}")]
    InvalidAccount(String),
    
    /// Error indicating an invalid script hash
    #[error("Invalid script hash: {0}")]
    InvalidScriptHash(String),
}

/// Errors that may occur within wallet operations.
#[derive(Error, Debug)]
pub enum WalletError {
    /// Error indicating an issue with the account's state
    #[error("Account state error: {0}")]
    AccountState(String),

    /// Indicates that no key pair is available
    #[error("No key pair")]
    NoKeyPair,

    /// Wraps errors from ECDSA signature operations
    #[error("ECDSA error: {0}")]
    EcdsaError(String),

    /// Represents errors during hex encoding/decoding
    #[error("Hex error: {0}")]
    HexError(String),

    /// Encapsulates errors from IO operations
    #[error("IO error: {0}")]
    IoError(String),

    /// Signifies that the wallet does not have a default account
    #[error("No default account")]
    NoDefaultAccount,

    /// Used when a key pair is found to be invalid
    #[error("Invalid key pair")]
    SignHashError,

    /// Wraps generic cryptographic errors
    #[error("Crypto error: {0}")]
    CryptoError(String),

    /// Covers errors related to transactions
    #[error("Transaction error: {0}")]
    TransactionError(String),

    /// Indicates issues during construction
    #[error("Builder error: {0}")]
    BuilderError(String),

    /// Indicates an invalid signature
    #[error("Invalid signature")]
    VerifyError,

    /// Errors related to Ledger hardware wallet operations
    #[error("Ledger error: {0}")]
    LedgerError(String),

    /// Error indicating no accounts in wallet
    #[error("No accounts in wallet")]
    NoAccounts,

    /// Errors related to YubiHSM operations
    #[error("YubiHSM error: {0}")]
    YubiHsmError(String),

    /// Errors from the RPC provider
    #[error(transparent)]
    ProviderError(#[from] ProviderError),

    /// Errors during account decryption
    #[error("Decryption error: {0}")]
    DecryptionError(String),

    /// Errors during transaction signing
    #[error("Signing error: {0}")]
    SigningError(String),

    /// Errors during file operations
    #[error("File error: {0}")]
    FileError(String),

    /// Errors during parsing operations
    #[error("Parse error: {0}")]
    ParseError(String),

    /// Errors during key import operations
    #[error("Import error: {0}")]
    ImportError(String),

    /// Invalid password provided
    #[error("Invalid password")]
    InvalidPassword,

    /// Errors during deserialization
    #[error("Deserialization error: {0}")]
    DeserializationError(String),
}

/// Represents errors that can occur within the signing process.
#[derive(Error, Debug)]
pub enum SignerError {
    /// Represents an error when an invalid passphrase is provided
    #[error("Invalid passphrase: {0}")]
    InvalidPassphrase(String),

    /// Indicates that the provided address is not valid
    #[error("Invalid address")]
    InvalidAddress,

    /// Wraps errors related to building or configuring objects
    #[error("Builder error: {0}")]
    BuilderError(String),

    /// Encapsulates errors that originate from wallet operations
    #[error(transparent)]
    WalletError(#[from] WalletError),

    /// Represents errors during hex encoding/decoding
    #[error("Hex error: {0}")]
    HexError(String),

    /// Covers general cryptographic errors
    #[error("Crypto error: {0}")]
    CryptoError(String),

    /// Error during hex decoding
    #[error("Hex decoding error: {0}")]
    RustcFromHexError(String),

    /// Indicates a failure related to type conversion
    #[error("Type error: {0}")]
    TypeError(String),
}

/// Errors that can occur during transaction operations.
#[derive(Error, Debug, PartialEq, Clone)]
pub enum TransactionError {
    /// Script format error
    #[error("Script format error: {0}")]
    ScriptFormat(String),
    
    /// Signer configuration error
    #[error("Signer configuration error: {0}")]
    SignerConfiguration(String),
    
    /// Invalid nonce
    #[error("Invalid nonce")]
    InvalidNonce,
    
    /// Invalid block
    #[error("Invalid block")]
    InvalidBlock,
    
    /// Invalid transaction
    #[error("Invalid transaction")]
    InvalidTransaction,
    
    /// Invalid witness condition
    #[error("Invalid witness condition")]
    InvalidWitnessCondition,
    
    /// Too many signers
    #[error("Too many signers")]
    TooManySigners,
    
    /// Duplicate signer
    #[error("Duplicate signer")]
    DuplicateSigner,
    
    /// No signers
    #[error("No signers")]
    NoSigners,
    
    /// No script
    #[error("No script")]
    NoScript,
    
    /// Empty script
    #[error("Empty script")]
    EmptyScript,
    
    /// Invalid sender
    #[error("Invalid sender")]
    InvalidSender,
    
    /// Invalid state
    #[error("Invalid state:{0}")]
    IllegalState(String),
    
    /// Transaction too large
    #[error("Transaction too large")]
    TxTooLarge,
    
    /// Transaction configuration error
    #[error("Transaction configuration error: {0}")]
    TransactionConfiguration(String),
    
    /// Codec error
    #[error("Codec error: {0}")]
    CodecError(String),
}
	#[error("Crypto error: {0}")]
	CryptoError(#[from] CryptoError),
	#[error(transparent)]
	ProviderError(#[from] ProviderError),
	#[error("Insufficient funds")]
	InsufficientFunds,
	#[error("Invalid script")]
	InvalidScript,
	#[error("Unknown transaction")]
	UnknownTransaction,
	#[error("Builder error: {0}")]
	BuilderError(#[from] BuilderError),
}
use crate::{
	builder::TransactionError, codec::CodecError, crypto::CryptoError, neo_clients::ProviderError,
};
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Clone)]
pub enum BuilderError {
	#[error("Invalid operation")]
	InvalidScript(String),
	#[error("Invalid operation")]
	InvalidOperation,
	#[error("Invalid argument")]
	InvalidArgument,
	#[error("Invalid state")]
	InvalidState,
	#[error("Invalid invocation")]
	InvalidInvocation,
	#[error("Stack overflow")]
	StackOverflow,
	#[error("Out of gas")]
	OutOfGas,
	#[error("Out of memory")]
	OutOfMemory,
	#[error("Out of cycles")]
	OutOfCycles,
	#[error("UnknownError")]
	UnknownError,
	#[error("Unsupported operation: {0}")]
	UnsupportedOperation(String),
	#[error("Invalid signer configuration: {0}")]
	SignerConfiguration(String),
	#[error("Invalid transaction configuration: {0}")]
	TransactionConfiguration(String),
	#[error("Invalid configuration: {0}")]
	InvalidConfiguration(String),
	#[error("Too many signers: {0}")]
	TooManySigners(String),
	#[error("Illegal state: {0}")]
	IllegalState(String),
	#[error("Illegal argument: {0}")]
	IllegalArgument(String),
	#[error("Invalid public key: {0}")]
	CodecError(#[from] CodecError),
	#[error("Crypto error: {0}")]
	CryptoError(#[from] CryptoError),
	#[error(transparent)]
	ProviderError(#[from] ProviderError),
	#[error(transparent)]
	TransactionError(Box<TransactionError>),
}

impl From<TransactionError> for BuilderError {
	fn from(err: TransactionError) -> Self {
		BuilderError::TransactionError(Box::new(err))
	}
}
// Copyright (c) 2023-2025 R3E Network
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! # NeoFS Error Handling
//!
//! This module provides error types for NeoFS operations.

use std::fmt;
use thiserror::Error;

/// Errors that can occur during NeoFS operations
#[derive(Error, Debug)]
pub enum NeoFSError {
	/// Connection error
	#[error("Connection error: {0}")]
	ConnectionError(String),

	/// Authentication error
	#[error("Authentication error: {0}")]
	AuthenticationError(String),

	/// Container error
	#[error("Container error: {0}")]
	ContainerError(String),

	/// Object error
	#[error("Object error: {0}")]
	ObjectError(String),

	/// Access control error
	#[error("Access control error: {0}")]
	ACLError(String),

	/// Serialization/deserialization error
	#[error("Serialization error: {0}")]
	SerializationError(String),

	/// Permission denied
	#[error("Permission denied: {0}")]
	PermissionDenied(String),

	/// Resource not found
	#[error("Resource not found: {0}")]
	NotFound(String),

	/// Invalid argument
	#[error("Invalid argument: {0}")]
	InvalidArgument(String),

	/// Operation timeout
	#[error("Operation timeout: {0}")]
	Timeout(String),

	/// Internal error
	#[error("Internal error: {0}")]
	InternalError(String),

	/// Conversion error
	#[error("Conversion error: {0}")]
	ConversionError(String),

	/// Not implemented
	#[error("Not implemented: {0}")]
	NotImplemented(String),

	/// Generic IO error
	#[error("IO error: {0}")]
	IOError(#[from] std::io::Error),

	/// Unexpected response
	#[error("Unexpected response: {0}")]
	UnexpectedResponse(String),
}

/// Result type for NeoFS operations
pub type NeoFSResult<T> = std::result::Result<T, NeoFSError>;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ProtocolError {
	#[error("RPC responses error: {error}")]
	RpcResponse { error: String },
	#[error("Invocation fault state: {error}")]
	InvocationFaultState { error: String },
	#[error("Client connection error: {message}")]
	ClientConnection { message: String },
	#[error("Cannot cast {item} to {target}")]
	StackItemCast { item: String, target: String },
	#[error("Illegal state: {message}")]
	IllegalState { message: String },
	#[error("HTTP error: {0}")]
	HttpError(#[from] reqwest::Error),
}
use thiserror::Error;

use crate::neo_codec::CodecError;

#[derive(Error, Debug, PartialEq, Eq, Hash, Clone)]
pub enum TypeError {
	#[error("Illegal argument: {0}")]
	IllegalArgument(String),
	#[error("Illegal state: {0}")]
	Deserialization(String),
	#[error("Illegal state: {0}")]
	IllegalState(String),
	#[error("Index out of bounds: {0}")]
	IndexOutOfBounds(String),
	#[error("Invalid configuration: {0}")]
	InvalidConfiguration(String),
	#[error("Runtime error: {0}")]
	Runtime(String),
	#[error("Invalid data: {0}")]
	InvalidData(String),
	#[error("Unsupported operation: {0}")]
	UnsupportedOperation(String),
	#[error("Transaction error: {0}")]
	Transaction(String),
	#[error("Invalid script: {0}")]
	InvalidScript(String),
	#[error("Invalid format: {0}")]
	InvalidFormat(String),
	#[error("neo-rs not initialized")]
	NeoNotInitialized,
	// #[error("Contract error: {0}")]
	// ContractError(#[from] ContractError),
	#[error("Unexpected returned type: {0}")]
	UnexpectedReturnType(String),
	#[error("Invalid private key")]
	InvalidPrivateKey,
	#[error("Invalid public key")]
	InvalidPublicKey,
	#[error("Invalid address")]
	InvalidAddress,
	#[error("Invalid signature")]
	InvalidSignature,
	#[error("Invalid encoding {0}")]
	InvalidEncoding(String),
	#[error("Invalid op code")]
	InvalidOpCode,
	#[error("Invalid argument {0}")]
	InvalidArgError(String),
	#[error("Invalid neo name {0}")]
	InvalidNeoName(String),
	#[error("Numeric overflow")]
	NumericOverflow,
	#[error("Wif error {0}")]
	WifError(String),
	#[error(transparent)]
	CodecError(#[from] CodecError),
}
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Clone)]
pub enum CryptoError {
	#[error("Invalid passphrase: {0}")]
	InvalidPassphrase(String),
	#[error("Invalid format: {0}")]
	InvalidFormat(String),
	#[error("invalid signature length, got {0}, expected 65")]
	HeaderOutOfRange(u8),
	#[error("Could not recover public key from signature")]
	RecoverFailed,
	#[error("Invalid public key")]
	InvalidPublicKey,
	#[error("Invalid private key")]
	InvalidPrivateKey,
	#[error("Invalid private key")]
	P256Error(#[from] p256::elliptic_curve::Error),
	#[error("Signing error")]
	SigningError,
	#[error("Signature verification error")]
	SignatureVerificationError,
	#[error(transparent)]
	FromHexError(#[from] hex::FromHexError),
	#[error("Decryption error: {0}")]
	DecryptionError(String),
	#[error("Key error: {0}")]
	KeyError(String),
}

#[derive(Error, Debug, Clone, PartialEq, Eq)]
pub enum Nep2Error {
	#[error("Invalid passphrase: {0}")]
	InvalidPassphrase(String),
	#[error("Invalid format: {0}")]
	InvalidFormat(String),
}

#[derive(Error, Debug, PartialEq, Eq, Hash, Clone)]
pub enum SignError {
	#[error("Header byte out of range: {0}")]
	HeaderOutOfRange(u8),
	#[error("Could not recover public key from signature")]
	RecoverFailed,
}
/// Converts an Option to a Result with a custom error message.
///
/// This utility function is useful for converting `Option<T>` to `Result<T, E>`
/// with a custom error message when the option is `None`.
///
/// # Examples
///
/// ```
/// use neo_error::option_to_result;
///
/// let option: Option<i32> = None;
/// let result = option_to_result(option, "Value not found");
/// assert!(result.is_err());
/// ```
pub fn option_to_result<T, E>(option: Option<T>, error: E) -> Result<T, E> {
    option.ok_or(error)
}

/// Adds context to a Result's error.
///
/// This utility function is useful for adding context to a `Result<T, E>`
/// with a custom error message when the result is `Err`.
///
/// # Examples
///
/// ```
/// use neo_error::with_context;
///
/// let result: Result<i32, &str> = Err("Error");
/// let result_with_context = with_context(result, |e| format!("Context: {}", e));
/// assert!(result_with_context.is_err());
/// ```
pub fn with_context<T, E, F, R>(result: Result<T, E>, f: F) -> Result<T, R>
where
    F: FnOnce(E) -> R,
{
    result.map_err(f)
}

/// Converts a Result to an Option.
///
/// This utility function is useful for converting `Result<T, E>` to `Option<T>`,
/// discarding the error information.
///
/// # Examples
///
/// ```
/// use neo_error::result_to_option;
///
/// let result: Result<i32, &str> = Err("Error");
/// let option = result_to_option(result);
/// assert!(option.is_none());
/// ```
pub fn result_to_option<T, E>(result: Result<T, E>) -> Option<T> {
    result.ok()
}

use thiserror::Error;

/// Comprehensive error type for the NeoRust SDK.
///
/// This enum provides a unified error handling system for all operations in the SDK.
/// It includes specific error types for different categories of errors and implements
/// conversions from various error types used throughout the codebase.
#[derive(Error, Debug)]
pub enum NeoError {
	/// An error for illegal or invalid argument values.
	#[error("Illegal argument: {0}")]
	IllegalArgument(String),

	/// An error that occurs during deserialization.
	#[error("Deserialization error: {0}")]
	Deserialization(String),

	/// An error for illegal state conditions.
	#[error("Illegal state: {0}")]
	IllegalState(String),

	/// An error for index out of bounds conditions.
	#[error("Index out of bounds: {0}")]
	IndexOutOfBounds(String),

	/// An error for invalid configuration settings.
	#[error("Invalid configuration: {0}")]
	InvalidConfiguration(String),

	/// A general runtime error.
	#[error("Runtime error: {0}")]
	Runtime(String),

	/// An error for invalid data.
	#[error("Invalid data: {0}")]
	InvalidData(String),

	/// An error for unsupported operations.
	#[error("Unsupported operation: {0}")]
	UnsupportedOperation(String),

	/// A general transaction error.
	#[error("Transaction error: {0}")]
	Transaction(String),

	/// An error for invalid scripts.
	#[error("Invalid script: {0}")]
	InvalidScript(String),

	/// An error for invalid format.
	#[error("Invalid format")]
	InvalidFormat,

	/// An error indicating that NeoRust has not been initialized.
	#[error("neo-rs not initialized")]
	NeoNotInitialized,

	/// An error related to smart contracts.
	#[error("Contract error: {0}")]
	ContractError(#[from] ContractError),

	/// An error for wallet-related issues.
	#[error("Wallet error: {0}")]
	WalletError(#[from] WalletError),

	/// An error for signing-related issues.
	#[error("Sign error: {0}")]
	SignError(#[from] SignError),

	/// A general transaction error.
	#[error("Transaction error: {0}")]
	TransactionError(#[from] TransactionError),

	/// An error for unexpected returned types.
	#[error("Unexpected returned type")]
	UnexpectedReturnType,

	/// An error for invalid private keys.
	#[error("Invalid private key")]
	InvalidPrivateKey,

	/// An error for invalid public keys.
	#[error("Invalid public key")]
	InvalidPublicKey,

	/// An error for invalid addresses.
	#[error("Invalid address")]
	InvalidAddress,

	/// An error for invalid signatures.
	#[error("Invalid signature")]
	InvalidSignature,

	/// An error for invalid encoding.
	#[error("Invalid encoding {0}")]
	InvalidEncoding(String),

	/// An error for invalid op codes.
	#[error("Invalid op code")]
	InvalidOpCode,

	/// An error for numeric overflow.
	#[error("Numeric overflow")]
	NumericOverflow,

	/// An error for WIF (Wallet Import Format) issues.
	#[error("Wif error {0}")]
	WifError(String),

	/// An error for provider-related issues.
	#[error("Provider error: {0}")]
	ProviderError(#[from] ProviderError),

	/// An error for codec-related issues.
	#[error("Codec error: {0}")]
	CodecError(#[from] CodecError),

	/// An error for type-related issues.
	#[error("Type error: {0}")]
	TypeError(#[from] TypeError),

	/// An error for protocol-related issues.
	#[error("Protocol error: {0}")]
	ProtocolError(#[from] ProtocolError),

	/// An error for JSON RPC-related issues.
	#[error("JSON RPC error: {0}")]
	JsonRpcError(String),

	/// An error for IO-related issues.
	#[error("IO error: {0}")]
	IoError(#[from] std::io::Error),

	/// An error for serialization-related issues.
	#[error("Serialization error: {0}")]
	SerializationError(String),
}

impl Into<TransactionError> for NeoError {
	fn into(self) -> TransactionError {
		TransactionError::TransactionConfiguration(self.to_string())
	}
}

impl From<serde_json::Error> for NeoError {
	fn from(err: serde_json::Error) -> Self {
		NeoError::SerializationError(err.to_string())
	}
}

impl From<String> for NeoError {
	fn from(err: String) -> Self {
		NeoError::IllegalState(err)
	}
}

impl From<&str> for NeoError {
	fn from(err: &str) -> Self {
		NeoError::IllegalState(err.to_string())
	}
}

use crate::{
	builder::{BuilderError, TransactionError},
	codec::CodecError,
	crypto::{CryptoError, Nep2Error, SignError},
	neo_clients::ProviderError,
	neo_contract::ContractError,
	neo_protocol::ProtocolError,
	neo_wallets::WalletError,
	TypeError,
};

impl From<BuilderError> for NeoError {
	fn from(err: BuilderError) -> Self {
		match err {
			BuilderError::InvalidScript(msg) => NeoError::InvalidScript(msg),
			BuilderError::InvalidOperation =>
				NeoError::UnsupportedOperation("Invalid operation".to_string()),
			BuilderError::InvalidArgument =>
				NeoError::IllegalArgument("Invalid argument".to_string()),
			BuilderError::InvalidState => NeoError::IllegalState("Invalid state".to_string()),
			BuilderError::InvalidInvocation =>
				NeoError::IllegalState("Invalid invocation".to_string()),
			BuilderError::StackOverflow => NeoError::Runtime("Stack overflow".to_string()),
			BuilderError::OutOfGas => NeoError::Runtime("Out of gas".to_string()),
			BuilderError::OutOfMemory => NeoError::Runtime("Out of memory".to_string()),
			BuilderError::OutOfCycles => NeoError::Runtime("Out of cycles".to_string()),
			BuilderError::UnknownError => NeoError::Runtime("Unknown error".to_string()),
			BuilderError::UnsupportedOperation(msg) => NeoError::UnsupportedOperation(msg),
			BuilderError::SignerConfiguration(msg) =>
				NeoError::IllegalState(format!("Signer configuration error: {}", msg)),
			BuilderError::TransactionConfiguration(msg) => NeoError::Transaction(msg),
			BuilderError::InvalidConfiguration(msg) => NeoError::InvalidConfiguration(msg),
			BuilderError::TooManySigners(msg) =>
				NeoError::IllegalState(format!("Too many signers: {}", msg)),
			BuilderError::IllegalState(msg) => NeoError::IllegalState(msg),
			BuilderError::IllegalArgument(msg) => NeoError::IllegalArgument(msg),
			BuilderError::CodecError(err) => NeoError::CodecError(err),
			BuilderError::CryptoError(err) => NeoError::from(err),
			BuilderError::ProviderError(err) => NeoError::ProviderError(err),
			BuilderError::TransactionError(err) => NeoError::TransactionError(*err),
		}
	}
}

impl From<CryptoError> for NeoError {
	fn from(err: CryptoError) -> Self {
		match err {
			CryptoError::InvalidPassphrase(msg) =>
				NeoError::IllegalArgument(format!("Invalid passphrase: {}", msg)),
			CryptoError::InvalidFormat(msg) => NeoError::InvalidFormat,
			CryptoError::HeaderOutOfRange(byte) =>
				NeoError::IllegalArgument(format!("Header byte out of range: {}", byte)),
			CryptoError::RecoverFailed =>
				NeoError::IllegalState("Could not recover public key from signature".to_string()),
			CryptoError::InvalidPublicKey => NeoError::InvalidPublicKey,
			CryptoError::InvalidPrivateKey => NeoError::InvalidPrivateKey,
			CryptoError::P256Error(err) => NeoError::IllegalState(format!("P256 error: {}", err)),
			CryptoError::SigningError => NeoError::SignError(SignError::RecoverFailed),
			CryptoError::SignatureVerificationError => NeoError::InvalidSignature,
			CryptoError::FromHexError(err) =>
				NeoError::InvalidEncoding(format!("Hex error: {}", err)),
			CryptoError::DecryptionError(msg) =>
				NeoError::IllegalState(format!("Decryption error: {}", msg)),
			CryptoError::KeyError(msg) => NeoError::IllegalState(format!("Key error: {}", msg)),
		}
	}
}

impl From<Nep2Error> for NeoError {
	fn from(err: Nep2Error) -> Self {
		match err {
			Nep2Error::InvalidPassphrase(msg) =>
				NeoError::IllegalArgument(format!("Invalid NEP-2 passphrase: {}", msg)),
			Nep2Error::InvalidFormat(msg) =>
				NeoError::InvalidEncoding(format!("Invalid NEP-2 format: {}", msg)),
		}
	}
}

// Implement From for reqwest::Error to handle HTTP errors
impl From<reqwest::Error> for NeoError {
	fn from(err: reqwest::Error) -> Self {
		NeoError::IoError(std::io::Error::new(
			std::io::ErrorKind::Other,
			format!("HTTP error: {}", err),
		))
	}
}

// Implement From for hex::FromHexError to handle hex decoding errors
impl From<hex::FromHexError> for NeoError {
	fn from(err: hex::FromHexError) -> Self {
		NeoError::InvalidEncoding(format!("Hex error: {}", err))
	}
}

// Implement From for std::num::ParseIntError to handle integer parsing errors
impl From<std::num::ParseIntError> for NeoError {
	fn from(err: std::num::ParseIntError) -> Self {
		NeoError::IllegalArgument(format!("Integer parsing error: {}", err))
	}
}

// Implement From for std::str::Utf8Error to handle UTF-8 decoding errors
impl From<std::str::Utf8Error> for NeoError {
	fn from(err: std::str::Utf8Error) -> Self {
		NeoError::InvalidEncoding(format!("UTF-8 error: {}", err))
	}
}
//! Error handling utilities for the Neo N3 SDK.

/// Converts an Option to a Result with a custom error message.
///
/// # Examples
///
/// ```
/// use neo::prelude::*;
/// use neo::neo_utils::error::option_to_result;
///
/// let value: Option<u32> = Some(42);
/// let result = option_to_result(value, || NeoError::IllegalState("Value is None".to_string()));
/// assert_eq!(result.unwrap(), 42);
/// ```
pub fn option_to_result<T, E, F>(option: Option<T>, err_fn: F) -> Result<T, E>
where
	F: FnOnce() -> E,
{
	option.ok_or_else(err_fn)
}

/// Adds context to an error.
///
/// # Examples
///
/// ```
/// use neo::prelude::*;
/// use neo::neo_utils::error::with_context;
///
/// let result: Result<u32, NeoError> = Err(NeoError::IllegalState("Original error".to_string()));
/// let result_with_context = with_context(result, || "Additional context");
/// ```
pub fn with_context<T, E, C, F, G>(
	result: Result<T, E>,
	context_fn: F,
	error_mapper: G,
) -> Result<T, E>
where
	E: std::fmt::Display,
	F: FnOnce() -> C,
	C: std::fmt::Display,
	G: FnOnce(String) -> E,
{
	result.map_err(|err| {
		let context = context_fn();
		error_mapper(format!("{}: {}", context, err))
	})
}

/// Converts a Result to an Option, logging the error if present.
///
/// # Examples
///
/// ```
/// use neo::prelude::*;
/// use neo::neo_utils::error::result_to_option;
///
/// let result: Result<u32, NeoError> = Ok(42);
/// let option = result_to_option(result);
/// assert_eq!(option, Some(42));
/// ```
pub fn result_to_option<T, E: std::fmt::Display>(result: Result<T, E>) -> Option<T> {
	match result {
		Ok(value) => Some(value),
		Err(err) => {
			eprintln!("Error: {}", err);
			None
		},
	}
}

/// Attempts to execute a fallible operation multiple times before giving up.
///
/// # Examples
///
/// ```
/// use neo::prelude::*;
/// use neo::neo_utils::error::retry;
/// use std::time::Duration;
///
/// async fn fallible_operation() -> Result<u32, NeoError> {
///     // Some operation that might fail
///     Ok(42)
/// }
///
/// # async fn example() -> Result<(), NeoError> {
/// let result = retry(
///     || async { fallible_operation().await },
///     3,
///     Duration::from_millis(100)
/// ).await;
/// # Ok(())
/// # }
/// ```
pub async fn retry<T, E, F, Fut>(
	operation: F,
	max_attempts: usize,
	delay: std::time::Duration,
) -> Result<T, E>
where
	F: Fn() -> Fut,
	Fut: std::future::Future<Output = Result<T, E>>,
	E: std::fmt::Display,
{
	let mut attempts = 0;
	let mut last_error = None;

	while attempts < max_attempts {
		match operation().await {
			Ok(value) => return Ok(value),
			Err(err) => {
				attempts += 1;
				if attempts < max_attempts {
					eprintln!("Attempt {} failed: {}. Retrying...", attempts, err);
					tokio::time::sleep(delay).await;
				}
				last_error = Some(err);
			},
		}
	}

	Err(last_error.expect("Should have at least one error after failed attempts"))
}
use std::{
	error::Error,
	fmt::{Display, Formatter},
};

use primitive_types::U256;

use crate::{JsonRpcError, ProviderError};

use super::WsError;

#[derive(Debug, thiserror::Error)]
pub enum WsClientError {
	/// Thrown if deserialization failed
	#[error(transparent)]
	JsonError(#[from] serde_json::Error),

	/// Thrown if the response could not be parsed
	#[error(transparent)]
	JsonRpcError(#[from] JsonRpcError),

	/// Internal lib error
	#[error(transparent)]
	InternalError(#[from] WsError),

	/// Remote server sent a Close message
	#[error("Websocket closed unexpectedly")]
	UnexpectedClose,

	/// Unexpected channel closure
	#[error("Unexpected internal channel closure. This is likely a bug. Please report via github")]
	DeadChannel,

	/// Thrown if the websocket responds with binary data
	#[error("Websocket responded with unexpected binary data")]
	UnexpectedBinary(Vec<u8>),

	/// PubSubClient asked to listen to an unknown subscription id
	#[error("Attempted to listen to unknown subscription: {0:?}")]
	UnknownSubscription(U256),

	/// Too Many Reconnects
	#[error("Reconnect limit reached")]
	TooManyReconnects,
}

impl crate::RpcError for WsClientError {
	fn as_error_response(&self) -> Option<&JsonRpcError> {
		if let WsClientError::JsonRpcError(err) = self {
			Some(err)
		} else {
			None
		}
	}

	fn as_serde_error(&self) -> Option<&serde_json::Error> {
		match self {
			WsClientError::JsonError(err) => Some(err),
			_ => None,
		}
	}
}

impl From<WsClientError> for ProviderError {
	fn from(src: WsClientError) -> Self {
		ProviderError::JsonRpcClientError(Box::new(src))
	}
}
use std::{error::Error, fmt::Debug, sync::Arc};

use crate::{crypto::CryptoError, neo_clients::JsonRpcError, TypeError};
use thiserror::Error;

#[derive(Debug, Error)]
/// An error thrown when making a call to the provider
pub enum ProviderError {
	/// An error during NNS name resolution
	#[error("nns name not found: {0}")]
	NnsError(String),
	/// Invalid reverse NNS name
	#[error("reverse nns name not pointing to itself: {0}")]
	NnsNotOwned(String),
	/// Error in underlying lib `serde_json`
	#[error(transparent)]
	SerdeJson(#[from] serde_json::Error),
	/// Error in underlying lib `hex`
	#[error(transparent)]
	HexError(#[from] hex::FromHexError),
	/// Error in underlying lib `reqwest`
	#[error(transparent)]
	HTTPError(#[from] Arc<reqwest::Error>),
	/// Reponse error
	#[error(transparent)]
	JsonRpcError(#[from] JsonRpcError),
	/// Custom error from unknown source
	#[error("custom error: {0}")]
	CustomError(String),
	/// RPC method is not supported by this provider
	#[error("unsupported RPC")]
	UnsupportedRPC,
	/// Node is not supported by this provider
	#[error("unsupported node client")]
	UnsupportedNodeClient,
	/// Signer is not available to this provider.
	#[error("Attempted to sign a transaction with no available signer. Hint: did you mean to use a SignerMiddleware?"
    )]
	SignerUnavailable,
	#[error("Illegal state: {0}")]
	IllegalState(String),
	#[error("Invalid address")]
	InvalidAddress,
	#[error(transparent)]
	CryptoError(#[from] CryptoError),
	#[error(transparent)]
	TypeError(#[from] TypeError),
	#[error("Invalid password")]
	InvalidPassword,
	/// Error parsing data
	#[error("Parse error: {0}")]
	ParseError(String),
	/// Error locking a mutex
	#[error("Lock error")]
	LockError,
	/// Protocol not found
	#[error("Protocol not found")]
	ProtocolNotFound,
	/// Network not found
	#[error("Network not found")]
	NetworkNotFound,
}

impl PartialEq for ProviderError {
	fn eq(&self, other: &Self) -> bool {
		match (self, other) {
			(ProviderError::SerdeJson(a), ProviderError::SerdeJson(b)) =>
				a.to_string() == b.to_string(),
			(ProviderError::HTTPError(a), ProviderError::HTTPError(b)) => a.status() == b.status(),
			(ProviderError::CustomError(a), ProviderError::CustomError(b)) => a == b,
			(ProviderError::UnsupportedRPC, ProviderError::UnsupportedRPC) => true,
			(ProviderError::UnsupportedNodeClient, ProviderError::UnsupportedNodeClient) => true,
			(ProviderError::SignerUnavailable, ProviderError::SignerUnavailable) => true,
			(ProviderError::IllegalState(a), ProviderError::IllegalState(b)) => a == b,
			(ProviderError::InvalidAddress, ProviderError::InvalidAddress) => true,
			(ProviderError::CryptoError(a), ProviderError::CryptoError(b)) => a == b,
			(ProviderError::TypeError(a), ProviderError::TypeError(b)) => a == b,
			(ProviderError::InvalidPassword, ProviderError::InvalidPassword) => true,
			_ => false,
		}
	}
}

// Implementing Clone manually for `ProviderError`
impl Clone for ProviderError {
	fn clone(&self) -> Self {
		match self {
			ProviderError::NnsError(message) => ProviderError::NnsError(message.clone()),
			ProviderError::NnsNotOwned(message) => ProviderError::NnsNotOwned(message.clone()),
			ProviderError::SerdeJson(error) => ProviderError::SerdeJson(serde_json::Error::io(
				std::io::Error::new(std::io::ErrorKind::Other, error.to_string()),
			)),
			ProviderError::HexError(error) => ProviderError::HexError(error.clone()),
			ProviderError::HTTPError(error) => ProviderError::HTTPError(Arc::clone(error)),
			ProviderError::JsonRpcError(error) => ProviderError::JsonRpcError(error.clone()),
			ProviderError::CustomError(message) => ProviderError::CustomError(message.clone()),
			ProviderError::UnsupportedRPC => ProviderError::UnsupportedRPC,
			ProviderError::UnsupportedNodeClient => ProviderError::UnsupportedNodeClient,
			ProviderError::SignerUnavailable => ProviderError::SignerUnavailable,
			ProviderError::IllegalState(message) => ProviderError::IllegalState(message.clone()),
			ProviderError::InvalidAddress => ProviderError::InvalidAddress,
			ProviderError::CryptoError(error) => ProviderError::CryptoError(error.clone()),
			ProviderError::TypeError(error) => ProviderError::TypeError(error.clone()),
			ProviderError::InvalidPassword => ProviderError::InvalidPassword,
			ProviderError::ParseError(message) => ProviderError::ParseError(message.clone()),
			ProviderError::LockError => ProviderError::LockError,
			ProviderError::ProtocolNotFound => ProviderError::ProtocolNotFound,
			ProviderError::NetworkNotFound => ProviderError::NetworkNotFound,
		}
	}
}
